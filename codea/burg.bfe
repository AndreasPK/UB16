%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "tree.h"

%}

%start code
%term ARG=1 FUNCTION=2 NOOP=3 RETURNSTAT=4 DOSTAT=5 VARDEF=6 VARASSIGN=7 TERMSTAT=8 STATS=9
%term EXPRTERM=10 CONSTTERM=11 CALLTERM=12 VARTERM=13 LESSEXPR=14 READEXPR=15 EQUALEXPR=16
%term OREXPR=17 MULTEXPR=18 PLUSEXPR=19 MINUSEXPR=20 NOTEXPR=21 VARUSE=22 GUARDEDLIST=23
%term GUARDED=24 FCALL=25 ARGEXPR=26 LASTARG=27 EXPR=28 ADDRWRITE=29

%%

code: FUNCTION(arguments)           # 5 # allocateParams(bnode->symbols); emit("FUNCTION", bnode);
arguments: LASTARG                 # 5 # clearReg();
arguments: ARG(arguments)          # 5 #
code: statement # 5 #
statement: RETURNSTAT(expr) # 5 # bnode->reg = kids[0]->reg; emit("RETURN", bnode); freeReg(kids[0]->reg);
expr: EXPR(expr) # 5 # bnode->reg=kids[0]->reg;
expr: NOTEXPR(term) # 5 # bnode->reg=newReg(); emit("NOTEXPR", bnode); freeReg(kids[0]->reg);
expr: MINUSEXPR(term) # 5 # bnode->reg=newReg(); emit("MINUSEXPR", bnode); freeReg(kids[0]->reg);
expr: PLUSEXPR(term, term) # 5 # bnode->reg = newReg(); emit("PLUSEXPR", bnode); freeReg(kids[0]->reg); freeReg(kids[1]->reg);
expr: PLUSEXPR(term, expr) # 5 # bnode->reg = newReg(); emit("PLUSEXPR", bnode); freeReg(kids[0]->reg); freeReg(kids[1]->reg);
expr: MULTEXPR(term, term) # 5 # bnode->reg = newReg(); emit("MULTEXPR", bnode); freeReg(kids[0]->reg); freeReg(kids[1]->reg);
expr: MULTEXPR(term, expr) # 5 # bnode->reg = newReg(); emit("MULTEXPR", bnode); freeReg(kids[0]->reg); freeReg(kids[1]->reg);
expr: OREXPR(term, term) # 5 # bnode->reg = newReg(); emit("OREXPR", bnode); freeReg(kids[0]->reg); freeReg(kids[1]->reg);
expr: OREXPR(term, expr) # 5 # bnode->reg = newReg(); emit("OREXPR", bnode); freeReg(kids[0]->reg); freeReg(kids[1]->reg);
expr: LESSEXPR(term, term) # 5 # bnode->reg = newReg(); emit("LESSEXPR", bnode); freeReg(kids[0]->reg); freeReg(kids[1]->reg);
expr: EQUALEXPR(term, term) # 5 # bnode->reg = newReg(); emit("EQUALEXPR", bnode); freeReg(kids[0]->reg); freeReg(kids[1]->reg);
expr: READEXPR(term) # 5 # bnode->reg = newReg(); emit("READEXPR", bnode); freeReg(kids[0]->reg);
expr: term # 1 # //puts("Shortcut? expr=term."); printf("%d\n", bnode);
term: VARUSE # 5 # bnode->reg = getRegNumber(bnode->symbols, bnode->name);
term: CONSTTERM # 5 # bnode->reg = newReg(); emit("CONSTTERM", bnode); //printf("%d = const $%d\n", bnode->reg, bnode->value);
term: FCALL # 5 # bnode->reg = newReg(); fprintf(stderr, "Error: Function call not supportet.\n");
term: EXPRTERM(expr) # 5 # bnode->reg = kids[0]->reg; //puts("store result of subexpression.");
statement: doexpr # 5 # fprintf(stderr, "DOSTAT: Do not supported.\n"); //printf("do stuff\n");
doexpr: DOSTAT # 5 #fprintf(stderr, "Do not yet supported.\n");
statement: VARASSIGN(memaddr, expr) # 5 # emit("MEMVARWRITE", bnode); freeReg(kids[1]->reg); freeReg(kids[0]->reg);
memaddr: ADDRWRITE(term) # 5 # bnode->reg = kids[0]->reg;
statement: VARDEF(expr) # 5 # ts = symFind(bnode->symbols, bnode->name); ts->reg = newReg(); bnode->reg=ts->reg; emit("VARDEF", bnode); freeReg(kids[0]->reg);
statement: VARASSIGN(VARUSE, expr) # 5 # ts = symFind(bnode->symbols, kids[0]->name); emit("VARASSIGN", bnode); freeReg(kids[1]->reg);
statement: term # 5 # printf("Free used reg and shit (statement: term).\n"); freeReg(kids[0]->reg);


%%
//reg: FUNCTION              # 1 # printf("Test I guess.\n");
//reg: num                   # 5 # printf("Value: %d\n", bnode->value);
//num: CONSTTERM             # 0

char codeBuffer[2048];

//Wasts memory but fuckid

char* asm_mv(char* buf, int from, int to)
{
  sprintf(buf, "#%s := %s\nmovq %s, %s\n", regNames[to], regNames[from], regNames[from], regNames[to]);
  return buf;
}

void emit(const char* what, NODEPTR_TYPE bnode)
{
  static char mv1[512];
  static char mv2[512];
  static char mv3[512];

  if(strcmp(what, "FUNCTION") == 0)
  {
    sprintf(codeBuffer, ".global %s\n%s:\n\n", bnode->name, bnode->name);
  }
  else if(strcmp(what, "RETURN") == 0)
  {
    sprintf(codeBuffer, "movq %s, %%rax \nret\n\n", regNames[bnode->reg]);
  }
  else if(strcmp(what, "MINUSEXPR") == 0)
  {
    asm_mv(mv1, LEFT_CHILD(bnode)->reg, bnode->reg);
    sprintf(codeBuffer, "#MINUSEXPR\n %s\n neg %s\n", mv1, regNames[bnode->reg]);
  }
  else if(strcmp(what, "NOTEXPR") == 0)
  {
    asm_mv(mv1, LEFT_CHILD(bnode)->reg, bnode->reg);
    sprintf(codeBuffer, "#NOTEXPR\n %s\n not %s\n", mv1, regNames[bnode->reg]);
  }
  else if(strcmp(what, "PLUSEXPR") == 0)
  {
    asm_mv(mv1, RIGHT_CHILD(bnode)->reg, bnode->reg);
    sprintf(codeBuffer,
    "#PLUSEXPR %3$s = %1$s + %2$s\n"
    "%4$s\n" //Move
    "addq %1$s, %3$s \n",
    regNames[LEFT_CHILD(bnode)->reg], regNames[RIGHT_CHILD(bnode)->reg], regNames[bnode->reg], mv1);
  }
  else if(strcmp(what, "MULTEXPR") == 0)
  {
    //asm_mv(mv1, RIGHT_CHILD(bnode)->reg, bnode->reg);
    sprintf(codeBuffer,
    "#MULTEXPR %3$s = %1$s * %2$s\n"
    //"%1$s\n" //mov
    "movq %2$s, %%rax\n"
    "imulq %1$s, %%rax \n"
    "movq %%rax, %3$s\n",
    regNames[LEFT_CHILD(bnode)->reg], regNames[RIGHT_CHILD(bnode)->reg], regNames[bnode->reg]);
  }
  else if(strcmp(what, "OREXPR") == 0)
  {
    asm_mv(mv1, RIGHT_CHILD(bnode)->reg, bnode->reg);
    sprintf(codeBuffer, "#OREXPR\n %s\n or %s, %s \n", mv1, regNames[LEFT_CHILD(bnode)->reg], regNames[bnode->reg]);
  }
  else if(strcmp(what, "LESSEXPR") == 0)
  {
    //-1 == TRUE und 0 == FALSE (Whyyyyyy)
    sprintf(codeBuffer,
      "#LESSEXPR\n"
      "push %%r15\n"
      "test %2$s, %3$s \n"
      "setl %%r15b\n"
      "dec %%r15b\n"
      "movsx %%r15b, %1$s\n"
      "pop %%r15\n",
      regNames[bnode->reg], regNames[RIGHT_CHILD(bnode)->reg], regNames[LEFT_CHILD(bnode)->reg]);
  }
  else if(strcmp(what, "EQUALEXPR") == 0)
  {
    //-1 == TRUE und 0 == FALSE (Whyyyyyy)
    sprintf(codeBuffer,
      "#EQUALEXPR\n"
      "push %%r15\n"
      "test %2$s, %3$s \n"
      "setz %%r15b\n"
      "dec %%r15b\n"
      "movsx %%r15b, %1$s\n"
      "pop %%r15\n",
      regNames[bnode->reg], regNames[RIGHT_CHILD(bnode)->reg], regNames[LEFT_CHILD(bnode)->reg]);
  }
  else if(strcmp(what, "READEXPR") == 0)
  {
    sprintf(codeBuffer,
      "#READEXPR\n"
      "movq (%1$s), %2$s # %2$s := *%1$s\n",
      regNames[LEFT_CHILD(bnode)->reg], regNames[bnode->reg]);
  }
  else if(strcmp(what, "CONSTTERM") == 0)
  {
    sprintf(codeBuffer,
      "#CONSTTERM\n"
      "movq $%1$ld, %2$s # %2$s := (const) %1$ld\n",
      bnode->value, regNames[bnode->reg]);
  }
  else if(strcmp(what, "MEMVARWRITE") == 0)
  {
    //*var = expr;
    sprintf(codeBuffer,
      "#WRITE TO ADDR STORED IN VAR\n"
      "movq %1$s, (%2$s) # *%2$s := %1$s\n",
      regNames[RIGHT_CHILD(bnode)->reg], regNames[LEFT_CHILD(bnode)->reg]);
  }
  else if(strcmp(what, "VARDEF") == 0)
  {
    //var = expr;
    sprintf(codeBuffer,
      "#WRITE TO VAR(DEF)\n"
      "movq %1$s, %2$s # %2$s := %1$s\n",
      regNames[LEFT_CHILD(bnode)->reg], regNames[bnode->reg]);
  }
  else if(strcmp(what, "VARASSIGN") == 0)
  {
    //var = expr;
    sprintf(codeBuffer,
      "#WRITE TO VAR\n"
      "movq %1$s, %2$s # %2$s := %1$s\n",
      regNames[RIGHT_CHILD(bnode)->reg], regNames[LEFT_CHILD(bnode)->reg]);
  }
  else
  {
    fprintf(stderr, "Invalid code node: %s\n", what);
    return;
  }


  puts(codeBuffer);
}

extern int yyparse(void);
void burm_reduce(NODEPTR_TYPE bnode, int goalnt);
psymList ts;

int getRegNumber(psymList list, const char* name)
{
  return symFind(list, name)->reg;
}

void allocateParams(psymList par)
{
  if(par == NULL)
    return;
  allocateParams(par->next);
  int i = newArgReg();
  par->reg = i;
  //printf("r%d = arg %s\n", i, par->name);
}

void invoke_burm(NODEPTR_TYPE root) {
	burm_label(root);
	burm_reduce(root, 1);
}

